---
title: "Rayshader_proj"
author: "Jonathan Huang"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

To get started, look at these resources

-   <https://wcmbishop.github.io/rayshader-demo/>

-   <https://rallydatajunkie.com/visualising-rally-stages/using-rayshader-to-render-2d-elevation-and-shade-views.html>

-   <https://www.tylermw.com/adding-open-street-map-data-to-rayshader-maps-in-r/>

-   <https://spencerschien.info/post/data_viz_how_to/high_quality_rayshader_visuals/>

# imortant functions 

- raster_to_matrix

- plot_map or plot_3D

- plot_gg


# Install Libraries

```{r}
library(tidyverse)
library(rayshader)
library(rayrender)
library(magick)
library(here)
library(elevatr) #elevation data
library(leaflet) #make base map
library(sf) # to read boundry shape file
library(patchwork)
library(ggpubr)
library(viridis)
library(rgl)
library(osmdata)
```

# Custom functions are made

```{r}
define_image_size <- function(bbox, major_dim = 400) {
  # calculate aspect ration (width/height) from lat/long bounding box
  aspect_ratio <- abs((bbox$p1$long - bbox$p2$long) / (bbox$p1$lat - bbox$p2$lat))
  # define dimensions
  img_width <- ifelse(aspect_ratio > 1, major_dim, major_dim*aspect_ratio) %>% round()
  img_height <- ifelse(aspect_ratio < 1, major_dim, major_dim/aspect_ratio) %>% round()
  size_str <- paste(img_width, img_height, sep = ",")
  list(height = img_height, width = img_width, size = size_str)
}
```

# test

```{r}
montereybay %>%
  sphere_shade(zscale = 10, texture = "imhof1") %>%
  add_shadow(ray_shade(montereybay, zscale = 50)) %>%
  add_shadow(ambient_shade(montereybay, zscale = 50)) %>%
  plot_3d(montereybay, zscale = 50, theta = -45, phi = 45, water = TRUE,
          windowsize = c(1000,800), zoom = 0.75, waterlinealpha = 0.3,
          wateralpha = 0.5, watercolor = "lightblue", waterlinecolor = "white")
render_snapshot()
```

# Making our own map to work we need:

-   image dimension match bounding box coordinate
-   image dimension of elevation & map overlay needs to be the same dimension

To make our own map, we need to define image aspect ratio

```{r}
# define bounding box with longitude/latitude coordinates
bbox <- list(
  p1 = list(long = -117.660861, lat = 33.282799),
  p2 = list(long = -117.485001, lat = 33.437839)
)

#Make base map
leaflet() %>%
  addTiles() %>% 
  addRectangles(
    lng1 = bbox$p1$long, lat1 = bbox$p1$lat,
    lng2 = bbox$p2$long, lat2 = bbox$p2$lat,
    fillColor = "transparent"
  ) %>%
  fitBounds(
    lng1 = bbox$p1$long, lat1 = bbox$p1$lat,
    lng2 = bbox$p2$long, lat2 = bbox$p2$lat,
  )

#need custom function
image_size <- define_image_size(bbox, major_dim = 600)
```


## Now try to do it with own data

### Load data
```{r}

elev <- file.path(here("jonathan","data","songs_gebco_elev.tif"))
img <- file.path(here("jonathan","data","songs_gebco_elev.tif"))
img2 <- png::readPNG(here("jonathan","data","songs_gebco_elev.png"))

#csv
songs_fish <- read.csv(here("jonathan","data","songs_clean.csv"))
songs_coord <- read.csv(here("jonathan","data","songs_coord.csv"))
```

### Raster Image
```{r}
elev_img <- raster_to_matrix(elev)

# calculate rayshader layers
ambmat <- ambient_shade(elev_img, zscale = 30)
raymat <- ray_shade(elev_img, zscale = 30, lambert = TRUE)
watermap <- detect_water(elev_img,zscale = 500)

# resize dimension as the hillshade
resized_overlay_file = paste0(tempfile(),".png")
grDevices::png(filename = resized_overlay_file, width = dim(elev_img)[1], height = dim(elev_img)[2])
par(mar = c(0,0,0,0))
plot(as.raster(img2))
dev.off()
overlay_img = file.path(here("jonathan","data","songs_gebco_elev.tif"))

elev_img %>%
  sphere_shade(texture = "imhof4") %>%
  add_water(watermap, color = "imhof4") %>%
  add_shadow(raymat, max_darken = 0.5) %>%
  add_shadow(ambmat, max_darken = 0.5) %>%
  plot_map()

```


#trying with ggplot
```{r}
songs_count <- songs_fish %>% 
  group_by( year,total_length, species_code, reef_code) %>%  #group analysis 
  filter(species_code %in% "SEPU") %>% 
  mutate(species_code = as_factor(factor(species_code,   #reorder the factors
  levels = c( "SEPU","PACL","PANE","EMJA","CHPU","OXCA"))),
  total_length = as.numeric(total_length), #change length to numeric
  reef_code = as_factor(reef_code),
  year = as_factor(year)) %>%    
  summarise(count = sum(count), #sum the count through the years
  total_area_sampled = sum(total_area_sampled)) %>%   
  mutate(size_density = count/total_area_sampled) %>% 
  uncount(count) %>%   #reorder so each row = 1 count
  select(year, species_code,reef_code,total_length,total_area_sampled, size_density) #reorder df order


p1 <- ggplot(songs_count %>% filter(reef_code%in% "WNR"),    #data 
       aes(x = total_length, color = year))+   #specify x & solor by year
  geom_density(binwidth = 3)+  #use density plot
    facet_wrap(~year, ncol = 1, scales = "free_y")+    #separate plots by species
  scale_x_continuous(breaks = seq(0,75, 5),
                     limits = c(0,75))+  #scale x to be max lenght at increment of 5cm
    scale_y_continuous(breaks = seq(0,0.08, 0.03),
                      limits = c(0,0.07) )+
  labs(x = "Total Length (mm)",    #edit axis & legend labels
       y = "frequency", 
       color = "Year",
       title = element_text("Size distribution on WNR"))+
  scale_color_viridis_d()+  #color palatte
  theme_classic()+
  theme(panel.background = element_rect(fill = "grey96", color = "black"),
        plot.title = element_text(hjust = 0.5),
        legend.position = "none",
        panel.spacing = unit(0, "mm"),
        strip.text = element_blank())

p2 <- ggplot(songs_count %>% filter(reef_code%in% c("BK","SMK")),    #data 
       aes(x = total_length, color = year))+   #specify x & solor by year
  geom_density(binwidth = 3)+   #use frequency polygon
  facet_wrap(~year, ncol = 1, scales = "free_y")+    #separate plots by species
  scale_x_continuous(breaks = seq(0,max(songs_fish$total_length), 5),
                     limits = c(0,NA))+  #scale x to be max length
    scale_y_continuous(breaks = seq(0,0.08, 0.03),
                      limits = c(0,0.07) )+
  labs(x = "Total Length (mm)",    #edit axis & legend labels
       y = "frequency", 
       color = "Year",
       title = element_text("Size distribution on BK & SMK"))+
  scale_color_viridis_d()+  #color palatte
  theme_classic()+
  theme(panel.background = element_rect(fill = "grey96", color = "black"),
        plot.title = element_text(hjust = 0.5),
        panel.spacing = unit(0, "mm"),
        strip.text = element_blank())

a <- ggarrange(p1+p2+rremove("ylab"), common.legend = TRUE, legend = "right")
a

```

Adding rayshader 
```{r}
plot_gg(p1, multicore = TRUE,width = 10, height = 10, scale = 400 )
render_snapshot()

```

THEST
```{r}
mtplot = ggplot(mtcars) + 
  geom_point(aes(x = mpg, y = disp, color = cyl)) + 
  scale_color_continuous(limits = c(0, 8))

par(mfrow = c(1, 2))
plot_gg(mtplot, width = 3.5, raytrace = TRUE, preview = TRUE)

plot_gg(mtplot)
Sys.sleep(0.2)
# render_snapshot(clear = TRUE,software_render = TRUE)
render_highquality(min_variance = 0, sample_method = "sobol")
```

```{r}
ggdiamonds = ggplot(diamonds) +
  stat_density_2d(aes(x = x, y = depth, fill = stat(nlevel)), 
                  geom = "polygon", n = 200, bins = 50,contour = TRUE) +
  facet_wrap(clarity~.) +
  scale_fill_viridis_c(option = "A")

par(mfrow = c(1, 2))

plot_gg(ggdiamonds, width = 5, height = 5, raytrace = FALSE, preview = TRUE)
plot_gg(ggdiamonds, width = 5, height = 5, multicore = TRUE, scale = 250, 
        zoom = 0.7, theta = 10, phi = 30, windowsize = c(800, 800))
Sys.sleep(0.2)
render_highquality(clear = TRUE)

render_snapshot(clear = TRUE)
```


Testing with map
```{r}
#Here, I load a map with the raster package.
loadzip = tempfile() 
download.file("https://tylermw.com/data/dem_01.tif.zip", loadzip)
localtif = raster::raster(unzip(loadzip, "dem_01.tif"))
unlink(loadzip)

#And convert it to a matrix:
elmat = raster_to_matrix(localtif)

#We use another one of rayshader's built-in textures:
elmat %>%
  sphere_shade(texture = "desert") %>%
  add_water(detect_water(elmat), color = "desert") %>%
  add_shadow(ray_shade(elmat, zscale = 3), 0.5) %>%
  add_shadow(ambient_shade(elmat), 0) %>%
  plot_3d(elmat, zscale = 10, fov = 0, theta = 135, zoom = 0.75, phi = 45, windowsize = c(1000, 800))
Sys.sleep(0.2)
render_snapshot()

render_camera(fov = 0, theta = 60, zoom = 0.75, phi = 45)
render_scalebar(limits=c(0, 5, 10),label_unit = "km",position = "W", y=50,
                scale_length = c(0.33,1))
render_compass(position = "E")
render_snapshot(clear=TRUE)
```

